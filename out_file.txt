1
 
 
  
   
    
     
     
      阮一峰的网络日志 
       &raquo; 首页
       &raquo; 档案 
      
      
       
       
        
         
         
         
         
         
        
       
       
      
      
       
      
     
    
   
   
    
     
      
       
        
         
          
           
           上一篇：乔布斯的管理课&nbsp;&nbsp;&nbsp;&nbsp; 
           下一篇：编译器的工作过程&nbsp;&nbsp;&nbsp; 
           
          
          分类：  
           JavaScrip 
           
          
         
        
        JavaScrip 运行机制详解：再谈vn Loop   
         作者： 阮一峰  日期： 2014年10月 8日  
         
         ，谈了我对vn Loop的理解。  
         。这才尴尬地发现，自己的理解是错的。我决定重写这个题目，详细、完整、正确地描述JavaScrip引擎的内部运行机制。下面就是我的重写。  进入正文之前，插播一条消息。我的新书《CMAScrip 6入门》出版了（版权页，内页1，内页2），铜版纸全彩印刷，非常精美，还附有索引（当然价格也比同类书籍略贵一点点）。预览和购买点击这里。     （2014年10月13日更新：本文已经做了较大修改，反映了我现在的认识。关于simou的更多解释和示例，请参阅我正在写的《JavaScrip标准参考教程》。）  （2014年10月11日更新：朴灵老师对本文做了评注，详细得指出了文中存在的错误说法，建议阅读。）  一、为什么JavaScrip是单线程？  JavaScrip语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScrip不能有多个线程呢？这样能提高效率啊。  JavaScrip的单线程，与它的用途有关。作为浏览器脚本语言，JavaScrip的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScrip同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？  所以，为了避免复杂性，从一诞生，JavaScrip就是单线程，这已经成了这门语言的核心特征，将来也不会改变。  为了利用多核CPU的计算能力，HML5提出Wb Workr标准，允许JavaScrip脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScrip单线程的本质。  二、任务队列  单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。  如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。  JavaScrip语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。  于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quo;任务队列&quo;（ask quu）的任务，只有&quo;任务队列&quo;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。  具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）  （1）所有同步任务都在主线程上执行，形成一个执行栈（xcuion conx sack）。  （2）主线程之外，还存在一个&quo;任务队列&quo;（ask quu）。只要异步任务有了运行结果，就在&quo;任务队列&quo;之中放置一个事件。  （3）一旦&quo;执行栈&quo;中的所有同步任务执行完毕，系统就会读取&quo;任务队列&quo;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。  （4）主线程不断重复上面的第三步。  下图就是主线程和任务队列的示意图。     只要主线程空了，就会去读取&quo;任务队列&quo;，这就是JavaScrip的运行机制。这个过程会不断重复。  三、事件和回调函数  &quo;任务队列&quo;是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&quo;任务队列&quo;中添加一个事件，表示相关的异步任务可以进入&quo;执行栈&quo;了。主线程读取&quo;任务队列&quo;，就是读取里面有哪些事件。  &quo;任务队列&quo;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quo;任务队列&quo;，等待主线程读取。  所谓&quo;回调函数&quo;（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。  &quo;任务队列&quo;是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，&quo;任务队列&quo;上第一位的事件就自动进入主线程。但是，由于存在后文提到的&quo;定时器&quo;功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。  四、vn Loop  主线程从&quo;任务队列&quo;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为vn Loop（事件循环）。  为了更好地理解vn Loop，请看下图（转引自Philip Robrs的演讲《Hlp, Im suck in an vnloop》）。     上图中，主线程运行的时候，产生堆（hap）和栈（sack），栈中的代码调用各种外部API，它们在&quo;任务队列&quo;中加入各种事件（click，load，don）。只要栈中的代码执行完毕，主线程就会去读取&quo;任务队列&quo;，依次执行那些事件所对应的回调函数。  执行栈中的代码（同步任务），总是在读取&quo;任务队列&quo;（异步任务）之前执行。请看下面这个例子。  
    var rq = nw XMLHpRqus();
    rq.opn(G, url);    
    rq.onload = funcion (){};    
    rq.onrror = funcion (){};    
    rq.snd();
  上面代码中的rq.snd方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取&quo;任务队列&quo;。所以，它与下面的写法等价。  
    var rq = nw XMLHpRqus();
    rq.opn(G, url);
    rq.snd();
    rq.onload = funcion (){};    
    rq.onrror = funcion (){};   
  也就是说，指定回调函数的部分（onload和onrror），在snd()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取&quo;任务队列&quo;。  五、定时器  除了放置异步任务的事件，&quo;任务队列&quo;还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做&quo;定时器&quo;（imr）功能，也就是定时执行的代码。  定时器功能主要由simou()和sInrval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论simou()。  simou()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。  
consol.log(1);
simou(funcion(){consol.log(2);},1000);
consol.log(3);
  上面代码的执行结果是1，3，2，因为simou()将第二行推迟到1000毫秒之后执行。  如果将simou()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。  
simou(funcion(){consol.log(1);}, 0);
consol.log(2);
  上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行&quo;任务队列&quo;中的回调函数。  总之，simou(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在&quo;任务队列&quo;的尾部添加一个事件，因此要等到同步任务和&quo;任务队列&quo;现有的事件都处理完，才会得到执行。  HML5标准规定了simou()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用rqusAnimaionFram()的效果要好于simou()。  需要注意的是，simou()只是将事件插入了&quo;任务队列&quo;，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在simou()指定的时间执行。  六、Nod.js的vn Loop  Nod.js也是单线程的vn Loop，但是它的运行机制不同于浏览器环境。  请看下面的示意图（作者@BusyRich）。     根据上图，Nod.js的运行机制如下。  （1）V8引擎解析JavaScrip脚本。  （2）解析后的代码，调用Nod API。  （3）libuv库负责Nod API的执行。它将不同的任务分配给不同的线程，形成一个vn Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。  （4）V8引擎再将结果返回给用户。  除了simou和sInrval这两个方法，Nod.js还提供了另外两个与&quo;任务队列&quo;有关的方法：procss.nxick和sImmdia。它们可以帮助我们加深对&quo;任务队列&quo;的理解。  procss.nxick方法可以在当前&quo;执行栈&quo;的尾部下一次vn Loop（主线程读取&quo;任务队列&quo;）之前触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。sImmdia方法则是在当前&quo;任务队列&quo;的尾部添加事件，也就是说，它指定的任务总是在下一次vn Loop时执行，这与simou(fn, 0)很像。请看下面的例子（via SackOvrflow）。  
procss.nxick(funcion A() {
  consol.log(1);
  procss.nxick(funcion B(){consol.log(2);});
});

simou(funcion imou() {
  consol.log(IMOU FIRD);
}, 0)
// 1
// 2
// IMOU FIRD
  上面代码中，由于procss.nxick方法指定的回调函数，总是在当前&quo;执行栈&quo;的尾部触发，所以不仅函数A比simou指定的回调函数imou先执行，而且函数B也比imou先执行。这说明，如果有多个procss.nxick语句（不管它们是否嵌套），将全部在当前&quo;执行栈&quo;执行。  现在，再看sImmdia。  
sImmdia(funcion A() {
  consol.log(1);
  sImmdia(funcion B(){consol.log(2);});
});

simou(funcion imou() {
  consol.log(IMOU FIRD);
}, 0);
  上面代码中，sImmdia与simou(fn,0)各自添加了一个回调函数A和imou，都是在下一次vn Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1IMOU FIRD2，也可能是IMOU FIRD12。  令人困惑的是，Nod.js文档中称，sImmdia指定的回调函数，总是排在simou前面。实际上，这种情况只发生在递归调用的时候。  
sImmdia(funcion (){
  sImmdia(funcion A() {
    consol.log(1);
    sImmdia(funcion B(){consol.log(2);});
  });

  simou(funcion imou() {
    consol.log(IMOU FIRD);
  }, 0);
});
// 1
// IMOU FIRD
// 2
  上面代码中，sImmdia和simou被封装在一个sImmdia里面，它的运行结果总是1IMOU FIRD2，这时函数A一定在imou前面触发。至于2排在IMOU FIRD的后面（即函数B在imou后面触发），是因为sImmdia总是将事件注册到下一轮vn Loop，所以函数A和imou是在同一轮Loop执行，而函数B在下一轮Loop执行。  我们由此得到了procss.nxick和sImmdia的一个重要区别：多个procss.nxick语句总是在当前&quo;执行栈&quo;一次执行完，多个sImmdia可能则需要多次loop才能执行完。事实上，这正是Nod.js 10.0版添加sImmdia方法的原因，否则像下面这样的递归调用procss.nxick，将会没完没了，主线程根本不会去读取&quo;事件队列&quo;！  
procss.nxick(funcion foo() {
  procss.nxick(foo);
});
  事实上，现在要是你写出递归的procss.nxick，Nod.js会抛出一个警告，要求你改成sImmdia。  另外，由于procss.nxick指定的回调函数是在本次&quo;事件循环&quo;触发，而sImmdia指定的是在下次&quo;事件循环&quo;触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查&quo;任务队列&quo;）。  （完）  
         
         
         文档信息  
          版权声明：自由转载非商用非衍生保持署名（创意共享3.0许可证） 
          发表日期： 2014年10月 8日 
          更多内容：  档案 &raquo;  JavaScrip  
          博客文集：《寻找思想之路》，《未来世界的幸存者》 
          社交媒体： wir， wibo 
          Fd订阅：   
          
         
        
       
       
         
        
       
       留言（109条）  
         
          
           
             cclinux 说：   
           
           写的不错  
           
            2014年10月 8日 21:28 | # | 引用  
           
          
         
         
          
           
             wuwnji 说：   
           
           补充：Clusr是nod js 多进程的API，是提高js资源使用效率的一种方法。  API描述：A singl insanc of Nod runs in a singl hrad. o ak advanag of mulicor sysms h usr will somims wan o launch a clusr of Nod procsss o handl h load.  
           
            2014年10月 8日 21:50 | # | 引用  
           
          
         
         
          
           
             im 说：   
           
           简言之就是JS只有一个主线程，主线程执行完执行栈的任务后去检查异步的任务队列，如果异步事件触发，则将其加到主线程的执行栈。  
           
            2014年10月 8日 22:24 | # | 引用  
           
          
         
         
          
           
             jruif 说：   
           
           在hps://mdium.com/@shijuvar/wbdvlopmnrndsfor2015andbyondc2d3c1f5718这篇文章中的关于nodjs的可维护性、可用性和高性能的论证不知道阮一峰大哥怎么看？  
           
            2014年10月 8日 23:27 | # | 引用  
           
          
         
         
          
           
             jar 说：   
           
           今天发现#aomshll#做同步ipc调用时，执行栈是可能被挂起的，相当于主线程slp了，等ipc返回后才会接着执行后续代码。如果挂起的时候同一段代码被vn又一次触发，逻辑就可能出错。  
           
            2014年10月 9日 00:41 | # | 引用  
           
          
         
         
          
           
             jar 说：   
           
           也就是说执行栈可能不能在一个loop内被执行完，因为会被挂起，是否挂起取决于运行环境和执行的操作种类。被挂起后前面注册的callback还是有可能先于执行栈剩余的代码触发。  
           
            2014年10月 9日 00:43 | # | 引用  
           
          
         
         
          
           
             rdnax 说：   
           
           补充一下imr相关的问题：  1. 其实并不是“有些浏览器规定了simou 的最小时间间隔”，这个最小时间间隔是W3C在HML标准中规定，规定要求低于4ms的时间间隔算为4ms。  2. procss.nxick在最新版nodjs中不被推荐使用，推荐使用sImmdia ，原因在于nxick是在当前帧介绍后立即执行，会阻断IO并且有最大数量限制；而sImmdia不会阻断IO，更像是simou(func, 0)  
           
            2014年10月 9日 01:06 | # | 引用  
           
          
         
         
          
           
             阮一峰 说：   
           
           @rdnax：  谢谢指出，我还不知道HML5把4毫秒写入了标准，已经改过来了。  我查了Nod.js 10.0的发布说明（ hp://blog.nodjs.org/2013/03/11/nodv0100sabl/ )，对于procss和sImmdia的差异，还在消化当中。  
           
            2014年10月 9日 06:31 | # | 引用  
           
          
         
         
          
           
             nimiz 说：   
           
           （3）libuv库负责Nod API的执行。它将不同的任务分配给不同的线程，形成一个vn Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。  不同任务会分给不同线程？不是直接调用相关操作系统接口？  
           
            2014年10月 9日 08:37 | # | 引用  
           
          
         
         
          
           
             wang 说：   
           
           我想转载这篇博客，可以吗？  
           
            2014年10月 9日 09:11 | # | 引用  
           
          
         
         
          
           
             roas_soul 说：   
           
           我觉得单线程的异步没什么意义。你看一下这个文章：  hp://cnn237111.blog.51co.com/2359144/1556987   
           
            2014年10月 9日 09:37 | # | 引用  
           
          
         
         
          
           
             万能小新 说：   
           
           rqusAnimFram应该是rqusAnimaionFram吧。  
           
            2014年10月 9日 09:39 | # | 引用  
           
          
         
         
          
           
             chpx 说：   
           
           单线程效率高是假，简化开发是真。  跟GUI相关的框架的都采用这种模型，Q、GK、MFC、Android UI框架、这里的JS都是这样的。  
           
            2014年10月 9日 12:02 | # | 引用  
           
          
         
         
          
           
             numbbbbb 说：   
           
           sImmdia的例子有问题吧，触发A之后并不是直接输出1，而是执行另一个sImmdia，这个sImmdia会把B添加到任务队列尾部，在执行B之前会触发simou的回调，所以例子的输出顺序应该是：  // IMOU FIRD  // 1  // 2   
           
            2014年10月 9日 22:52 | # | 引用  
           
          
         
         
          
           
             阮一峰 说：   
           
           @numbbbbb：  谢谢指出，你说得对，例子有错，已经改过来了。  
           
            2014年10月 9日 23:11 | # | 引用  
           
          
         
         
          
           
             阮一峰 说：   
           
           
            引用万能小新的发言：  rqusAnimFram应该是rqusAnimaionFram吧。  谢谢指出，改过来了。  
           
            2014年10月 9日 23:39 | # | 引用  
           
          
         
         
          
           
             Lo 说：   
           
           sImmdia(funcion A() {  consol.log(1);  sImmdia(funcion B(){consol.log(2);});  });  simou(funcion imou() {  consol.log(IMOU FIRD);  }, 0)  // 1  // IMOU FIRD  // 2  ===========  同样的这段代码, 为什么后边的说 Immdia 和 imou 的先后顺序不确定呢? 求解释...  
           
            2014年10月10日 17:38 | # | 引用  
           
          
         
         
          
           
             mamamiya 说：   
           
           hps://app.yinxiang.com/shard/s8/sh/b72f246a89d434b85f0a36420849b84/59bad790bdcf6b0a66b8b93d5acbad  朴灵对您文章的评注。语言虽然略显犀利，但是个人觉得评注的应该是对的。  
           
            2014年10月10日 19:03 | # | 引用  
           
          
         
         
          
           
             阮一峰 说：   
           
           @Lo：  谢谢指出，我修改文章时，脑子糊涂了，已经改过来了。  
           
            2014年10月10日 19:22 | # | 引用  
           
          
         
         
          
           
             csu 说：   
           
           hps://app.yinxiang.com/shard/s8/sh/b72f246a89d434b85f0a36420849b84/59bad790bdcf6b0a66b8b93d5acbad阮老师,有一位高手（前端专家朴灵）对你的这篇文章提出了不少看法，你可以看看。  
           
            2014年10月10日 20:22 | # | 引用  
           
          
         
         
          
           
             Dan 说：   
           
           hps://app.yinxiang.com/shard/s8/sh/b72f246a89d434b85f0a36420849b84/59bad790bdcf6b0a66b8b93d5acbad  阮老师 您被打脸了  
           
            2014年10月11日 09:32 | # | 引用  
           
          
         
         
          
           
             SO 说：   
           
           门都还没入就来写科普  
           
            2014年10月11日 09:39 | # | 引用  
           
          
         
         
          
           
             BluicQ 说：   
           
           hps://app.yinxiang.com/shard/s8/sh/b72f246a89d434b85f0a36420849b84/59bad790bdcf6b0a66b8b93d5acbad  阮老师，看了没？  
           
            2014年10月11日 10:51 | # | 引用  
           
          
         
         
          
           
             金戈铁马 说：   
           
           打人不打脸，绝交。。  
           
            2014年10月11日 14:50 | # | 引用  
           
          
         
         
          
           
             rdnax 说：   
           
           
            引用mamamiya的发言：  hps://app.yinxiang.com/shard/s8/sh/b72f246a89d434b85f0a36420849b84/59bad790bdcf6b0a66b8b93d5acbad  朴灵对您文章的评注。语言虽然略显犀利，但是个人觉得评注的应该是对的。  看了一下不觉得评注对到哪里去，只有吹毛求疵之感。 比如同步异步介绍，本来就无大错；比如nod图里面的OS opraion，推敲一下就可以猜到那是指同步操作（自然不走vn loop了）；至于wachr啥的，显然只是实现上的特色，即使用同一个quu实现也未尝不可。 
           
           
            2014年10月12日 16:39 | # | 引用  
           
          
         
         
          
           
             zzm 说：   
           
           我去，被朴灵狠劈，现在更乱了  
           
            2014年10月12日 19:48 | # | 引用  
           
          
         
         
          
           
             牛牛 说：   
           
           请问你一个问题，你的主业是金融，为什么还花这么多时间在编程上？即使你明知道不管你如何努力地来提高自己的编程水平，也无法改变业余的地位，也得不到什么实际的回报。  
           
            2014年10月12日 20:03 | # | 引用  
           
          
         
         
          
           
             zzm 说：   
           
           
            引用rdnax的发言：    看了一下不觉得评注对到哪里去，只有吹毛求疵之感。  比如同步异步介绍，本来就无大错；比如nod图里面的OS opraion，推敲一下就可以猜到那是指同步操作（自然不走vn loop了）；至于wachr啥的，显然只是实现上的特色，即使用同一个quu实现也未尝不可。  多看几眼还真是  
           
            2014年10月12日 20:09 | # | 引用  
           
          
         
         
          
           
             淘杰 说：   
           
           &quo;sImmdia的另一个重要特点：一次&quo;事件循环&quo;只能触发一个由sImmdia指定的回调函数。&quo;  这个说法其实也不准确，准确的说是因为sImmdia是在事件循环结束后触发，  sImmdia(funcion A() {  consol.log(1);  sImmdia(funcion B(){consol.log(2);});  });  simou(funcion imou() {  consol.log(IMOU FIRD);  }, 0);  当第一个loop结束后触发第一次sImmdia，此时sImmdia调用之后开始将回调函数加入队列等待下一个loop结束触发, 而不是一次&quo;事件循环&quo;只能触发一个由sImmdia指定的回调函数。多个只要在loop前已经执行掉同样会在一次&quo;事件循环&quo;中一起触发。  sImmdia(funcion A() {  consol.log(1);  });  sImmdia(funcion B(){consol.log(2);});  实际上，上面调用2次sImmdia会形成一个immdiaQuu链表，loop结束后会执行改链表里所有的函数～   
           
            2014年10月12日 22:47 | # | 引用  
           
          
         
         
          
           
             淘杰 说：   
           
           
            引用Lo的发言：  sImmdia(funcion A() {  consol.log(1);  sImmdia(funcion B(){consol.log(2);});  });  simou(funcion imou() {  consol.log(IMOU FIRD);  }, 0)  // 1  // IMOU FIRD  // 2  ===========  同样的这段代码, 为什么后边的说 sImmdia 和 imou 的先后顺序不确定呢? 求解释...  @Lo , nod中的底层loop有3种运行模式，DFAUL, UV_RUN_ONC,UV_RUN_NOWAI具体差异详见libuv文档 。 刚启动nod解析执行脚本时以UV_RUN_ONC的模式执行也就是说第一次loop是UV_RUN_ONC模式，在每一个loop中先检测imrs，然后进入io_poll此时会阻塞等待事件发生，事件发生后执行sImmdia中的回调，当以UV_RUN_ONC模式执行的时候会再次检测imrs 。照这个原理来说，sImmdia应该比simou先执行。  simou(fn,0) 底层实际执行的是 simou(fn,1), 此时会向loop队列中注册一个超时事件，假设注册时当前时间戳是1000，它的过期时间就是1001。按上面的说法1ms 第一次loop执行完后先执行sImmdia回调，再执行imr回调。但是有一点别忘了，您的计算机此时还有其他任务在处理，cpu不是全部用来跑你的nod进程的，也就是说虽然cpu很快，但执行指令总得花点时间吧，从simou(fn,0)注册一个1ms的超时事件到第一次执行imrs可能就已经花了1ms的时间，此时系统时间已经到1001了，那么对应的imr回调当然就会先于sImmdia执行，所以说Immdia 和 imou 的先后顺序不确定。  
           
            2014年10月12日 23:08 | # | 引用  
           
          
         
         
          
           
             阮一峰 说：   
           
           
            引用淘杰的发言：  当第一个loop结束后触发第一次sImmdia，此时sImmdia调用之后开始将回调函数加入队列等待下一个loop结束触发, 而不是一次&quo;事件循环&quo;只能触发一个由sImmdia指定的回调函数。多个只要在loop前已经执行掉同样会在一次&quo;事件循环&quo;中一起触发。   谢谢指出，确实如此，已经改正了。   
           
            2014年10月13日 09:11 | # | 引用  
           
          
         
         
          
           
             crazy 说：   
           
           究竟谁对谁错呢？现在有些混乱了  
           
            2014年10月13日 09:31 | # | 引用  
           
          
         
         
          
           
             Jak Wings 说：   
           
           
            引用crazy的发言：  究竟谁对谁错呢？现在有些混乱了  普通应用没必要这么吹毛球疵，只要了解一下 procss.nxick 和 sImmdia 的区别就好了，官方的 API 说明已经解释得很好，带实际应用示例。阮先生没有把官方介绍的 procss.nxick 实际用例放上来直接硬剥是有点无趣了。  
           
            2014年10月13日 09:39 | # | 引用  
           
          
         
         
          
           
             Jak Wings 说：   
           
           
           
             我们由此得到了procss.nxick和sImmdia的一个重要区别……事实上，这正是Nod.js 10.0版添加sImmdia方法的原因，否则像下面这样的递归调用procss.nxick，将会没完没了…… 
            不知道哪里来的「事实上」，官方示例已经明确地说「his is no a simpl alias o simou(fn, 0)」了，当然也更不可能原本作为 sImmdia 的替代，或者反过来。procss.nxick 是有特殊用途的，并还是单单脱离原有的 vn loop。  
           
            2014年10月13日 09:46 | # | 引用  
           
          
         
         
          
           
             Jak Wings 说：   
           
           
            引用Jak Wings的发言：    不知道哪里来的「事实上」，官方示例已经明确地说「his is no a simpl alias o simou(fn, 0)」了，当然也更不可能原本作为 sImmdia 的替代，或者反过来。procss.nxick 是有特殊用途的，并还是单单脱离原有的 vn loop。  囧，抱歉，才看了官方发布说明，看来 procss.nxick 是被滥用后才加上 sImmdia 的。不过我还是觉得 API 说明页面的说明比发布那时的好，sImmdia 是和 simou 使用同一个 vn loop 的，应该凸出了和 procss.nxick 的不同了，应该也是后来提防大家滥用才这么设定的。  
           
            2014年10月13日 09:56 | # | 引用  
           
          
         
         
          
           
             Jak Wings 说：   
           
           
           
             令人困惑的是，Nod.js文档中称，sImmdia指定的回调函数，总是排在simou前面。实际上，这种情况只发生在递归调用的时候。 
            我刚刚用 v0.10.32 和 v0.11.14测试过了，这个也没有保证。我能得到 1...2 和 12... 两种结果，甚至是 ...12。信不信由你。  
           
            2014年10月13日 10:14 | # | 引用  
           
          
         
         
          
           
             阮一峰 说：   
           
           
            引用Jak Wings的发言：    我刚刚用 v0.10.32 和 v0.11.14测试过了，这个也没有保证。我能得到 1...2 和 12... 两种结果，甚至是 ...12。信不信由你。  我测的结果，一直都是12。难道这个也不确定……   
           
            2014年10月13日 14:06 | # | 引用  
           
          
         
         
          
           
             Lo 说：   
           
           @淘杰：  谢谢解释~  
           
            2014年10月13日 14:44 | # | 引用  
           
          
         
         
          
           
             林夕轩 说：   
           
           
            引用淘杰的发言：  simou(fn,0) 底层实际执行的是 simou(fn,1), 此时会向loop队列中注册一个超时事件，假设注册时当前时间戳是1000，它的过期时间就是1001。按上面的说法1ms 第一次loop执行完后先执行sImmdia回调，再执行imr回调。但是有一点别忘了，您的计算机此时还有其他任务在处理，cpu不是全部用来跑你的nod进程的，也就是说虽然cpu很快，但执行指令总得花点时间吧，从simou(fn,0)注册一个1ms的超时事件到第一次执行imrs可能就已经花了1ms的时间，此时系统时间已经到1001了，那么对应的imr回调当然就会先于sImmdia执行，所以说Immdia 和 imou 的先后顺序不确定。  这么解释的确合理，定时器的原理都是如此，告诉cpu有个任务在某个时间应该执行。但也只有cpu有空的时候，才能尽快执行才可。  
           
            2014年10月14日 11:10 | # | 引用  
           
          
         
         
          
           
             猴子 说：   
           
           读完正文觉得很多东西是纯理论的理解，有些可能来源于猜测。  这篇文章更该是一个学习笔记，文中提到的很多vn其实和Javascrip语言完全无关，纯粹是浏览器的处理和行为。  对于任何一个不基于浏览器且支持多线程的程序来讲（比如随便一个C实现的游戏），会发现同样的事件处理比如鼠标操作、键盘快捷键等等，是需要去自己单独实现的，那么也许实现中使用了vn loop，但这一部分从未集成到语言中，对吧？  理解这个事情更好的办法是真的去实现一个类似的程序。  
           
            2014年10月14日 16:37 | # | 引用  
           
          
         
         
          
           
             陈佳 说：   
           
           看来我需要买书好好学学了。  
           
            2014年10月16日 01:51 | # | 引用  
           
          
         
         
          
           
             Jak Wings 说：   
           
           
            引用阮一峰的发言：    我测的结果，一直都是12。难道这个也不确定……   对了，V8 引擎能代表所有实现了 S6 的浏览器的具体实现么？  
           
            2014年10月16日 15:09 | # | 引用  
           
          
         
         
          
           
             阮一峰 说：   
           
           
            引用Jak Wings的发言：  V8 引擎能代表所有实现了 S6 的浏览器的具体实现么？  问题是Nod采用了V8  
           
            2014年10月16日 17:33 | # | 引用  
           
          
         
         
          
           
             sackvoid 说：   
           
           的确有些说法不太严谨~~~  
           
            2014年10月16日 17:36 | # | 引用  
           
          
         
         
          
           
             爱因斯坦 说：   
           
           
            引用牛牛的发言：  请问你一个问题，你的主业是金融，为什么还花这么多时间在编程上？即使你明知道不管你如何努力地来提高自己的编程水平，也无法改变业余的地位，也得不到什么实际的回报。  请问你一个问题，你的主业是专利局小职员，为什么还花这么多时间在物理上？即使你明知道不管你如何努力地来提高自己的数学水平，也无法改变业余的地位，也得不到什么实际的回报。  
           
            2014年10月18日 03:45 | # | 引用  
           
          
         
         
          
           
             朴素博客 说：   
           
           
            引用爱因斯坦的发言：    请问你一个问题，你的主业是专利局小职员，为什么还花这么多时间在物理上？即使你明知道不管你如何努力地来提高自己的数学水平，也无法改变业余的地位，也得不到什么实际的回报。 因为热爱 所以热爱 
           
           
            2014年10月18日 17:18 | # | 引用  
           
          
         
         
          
           
             腊月乘凉 说：   
           
           阮大侠你就别再祸害程序员了，建议先补一下计算机组成原理，编译原理，算法导论，C语言基础再来出书，不然你出了也没人敢看吧。另外起码要实践一点儿项目。  var rq = nw XMLHpRqus();  rq.opn(G, url);  rq.onload = funcion (){};  rq.onrror = funcion (){};  rq.snd();  var rq = nw XMLHpRqus();  rq.opn(G, url);  rq.snd();  rq.onload = funcion (){};  rq.onrror = funcion (){};   你说这俩等价，等价个毛线啊，rq.snd();之后如果浏览器有缓存这个函数会立即返回，也就是说不管你是onload还是onrror都不会执行。要先绑定回调再去执行snd()，这样才没bug。  
           
            2014年10月22日 00:09 | # | 引用  
           
          
         
         
          
           
             jiangjunzhangas 说：   
           
           不过瘾  
           
            2014年10月22日 22:02 | # | 引用  
           
          
         
         
          
           
             ARM Linux 说：   
           
           Js原来还有这么深奥的功能  
           
            2014年10月28日 13:53 | # | 引用  
           
          
         
         
          
           
             小雪 说：   
           
           
            引用牛牛的发言：  请问你一个问题，你的主业是金融，为什么还花这么多时间在编程上？即使你明知道不管你如何努力地来提高自己的编程水平，也无法改变业余的地位，也得不到什么实际的回报。  阮老师已经是程序员了……  
           
            2014年10月30日 19:38 | # | 引用  
           
          
         
         
          
           
             Hiccup 说：   
           
           不正确的文章为什么不删掉  
           
            2014年10月31日 11:54 | # | 引用  
           
          
         
         
          
           
             rducm 说：   
           
           想不到阮老师去了阿里巴巴做前端阿  
           
            2014年10月31日 13:53 | # | 引用  
           
          
         
         
          
           
             渠德通 说：   
           
           很长一段时间，googl日历无法访问，但网上又找不到好用的在线日历软件，偶然间看到您开发的这个简易版googl日历，发自内心的高兴，但所有的浏览器都用了，就是无法联接，联的过程中，显示一个进度条，等到100%之后，马上出现一个空白页，提示无法连接。郁闷中！！ 如果才能正常联接，期待您的指点。我的邮箱为：qudong@www5a.com,手机：13501282988.如果可能能话，我愿意为您长期进行测试各项功能  
           
            2014年10月31日 15:10 | # | 引用  
           
          
         
         
          
           
             alx 说：   
           
           欢迎兔哥加入大阿里！  
           
            2014年10月31日 21:38 | # | 引用  
           
          
         
         
          
           
             陈明 说：   
           
           强烈建议博主开个微信公众号！  
           
            2014年11月 2日 09:30 | # | 引用  
           
          
         
         
          
           
             Byron 说：   
           
           
            引用rducm的发言：  想不到阮老师去了阿里巴巴做前端阿  是为了和朴灵PK才来的么？  
           
            2014年11月 3日 10:20 | # | 引用  
           
          
         
         
          
           
             花生大仙 说：   
           
           好久没更新博客了，甚是想念。  
           
            2014年11月 3日 14:01 | # | 引用  
           
          
         
         
          
           
             赵秀芳 说：   
           
           听说阮先生，要去蚂蚁金服了...  阮先生好久不更新了，要记得常常更新哦。  
           
            2014年11月 6日 11:05 | # | 引用  
           
          
         
         
          
           
             Svn 说：   
           
           @腊月乘凉：  确实是这样的  
           
            2014年11月11日 00:14 | # | 引用  
           
          
         
         
          
           
             雁南飞 说：   
           
           有没有办法查看Funcion Objc的inrnal propry？  
           
            2014年11月25日 11:45 | # | 引用  
           
          
         
         
          
           
             flix 说：   
           
           有一个问题，事件执行的粒度是多大？是一个函数还是一个语句块？  在大量的异步方法同时操作一个变量的时候，会不会出现类似线程的问题呢？   
           
            2014年11月25日 11:57 | # | 引用  
           
          
         
         
          
           
             袁梓民 说：   
           
           var sar = nw Da();  consol.log(sar);  var prin = simou(funcion() {  var nd = nw Da();  consol.log(从开始到执行这个simou函数花掉的时间为, nd  sar, &quo;ms&quo;);  }, 1000);  var s = [];  for(var i = 0; i s.push(i);  }  var middl = nw Da();  consol.log(执行数组操作所花掉的时间为：,middl  sar, ms);  我想请教一下这里的simou会在什么时候执行？我再nod里面和浏览器里面分别跑了几次。得到的结果是：  nod：  执行数组操作所花掉的时间为： 379 ms  从开始到执行这个simou函数花掉的时间为： 1030ms  按照您的说法，simou应该是尽可能在能执行的时候执行，这里运算操作只是379ms，没有超过初始设定的1000ms，按道理1030ms不应该是1001ms么？  浏览器：  执行数组操作所花掉的时间为： 8016 ms  从开始到执行这个simou函数花掉的时间为 8017 ms  这个结果中，运算时间很长，远远超过了1000ms，所以simou不是在1001ms执行的，而是等到元算结束之后立即执行，那么结果奇怪了，这个simou时间设定成1000ms是从什么时候开始的？我的理解是一开始就计时，但是1000ms无法执行，等到数组操作完成之后才能执行，这样计时操作似乎没有存在的意义了。   
           
            2014年11月26日 14:14 | # | 引用  
           
          
         
         
          
           
             subbornlaf 说：   
           
           原来水平也不过如此。有点水平的人都看得懂朴灵的批注比较准确。  
           
            2014年12月 2日 07:13 | # | 引用  
           
          
         
         
          
           
             rufushuang 说：   
           
           从这篇文章看得出，阮老师不是科班出身的  不过非科班的也有非科班的好，希望能够继续有文章看  
           
            2014年12月11日 14:52 | # | 引用  
           
          
         
         
          
           
             水中月镜中花 说：   
           
           阮老师，那如果在ajax的回调函数中，存在simOu函数，这个时候回调函数中还是按照vn loop的机制吗？就是说回调函数相当于主线程，把simOu函数放在任务对象，先执行回调函数的代码再执行执行simou函数？  
           
            2014年12月17日 14:59 | # | 引用  
           
          
         
         
          
           
             欧文 说：   
           
           阮老师，你的站点统计工具：spcificclick好像不工作耶，请须知。  
           
            2015年1月26日 14:28 | # | 引用  
           
          
         
         
          
           
             linda 说：   
           
           对您的网站有一些小提议，供您参考。  1、给页面右下角或者右侧加一个按钮，可以直接跳到最顶层，这样对读者来说很方便，因为一直拖动滚动条很麻烦。同时，这个按钮相对于浏览器窗口是固定的。  2、给标题下面加上您文章的写作日期。作为读者我感觉这个时间挺重要的。  
           
            2015年1月28日 15:43 | # | 引用  
           
          
         
         
          
           
             aomax 说：   
           
           嗯，还是比较实用的内容呢，我会长期关注的。  
           
            2015年2月 5日 20:48 | # | 引用  
           
          
         
         
          
           
             supid 说：   
           
           请不要说你在淘宝工作好吗？淘宝不都是大牛吗？  
           
            2015年3月10日 11:22 | # | 引用  
           
          
         
         
          
           
             supid 说：   
           
           淘宝的人都喜欢出书吗？竟然都敢出书？  
           
            2015年3月10日 11:24 | # | 引用  
           
          
         
         
          
           
             1024bi 说：   
           
           
            引用腊月乘凉的发言：  阮大侠你就别再祸害程序员了，建议先补一下计算机组成原理，编译原理，算法导论，C语言基础再来出书，不然你出了也没人敢看吧。另外起码要实践一点儿项目。  var rq = nw XMLHpRqus();  rq.opn(G, url);  rq.onload = funcion (){};  rq.onrror = funcion (){};  rq.snd();  var rq = nw XMLHpRqus();  rq.opn(G, url);  rq.snd();  rq.onload = funcion (){};  rq.onrror = funcion (){};   你说这俩等价，等价个毛线啊，rq.snd();之后如果浏览器有缓存这个函数会立即返回，也就是说不管你是onload还是onrror都不会执行。要先绑定回调再去执行snd()，这样才没bug。  擦，能不能不要绑定宿主环境。  
           
            2015年3月31日 17:16 | # | 引用  
           
          
         
         
          
           
             简陋的以数据 说：   
           
           感觉文章的表述有些乱，比如“不进入主线程、而进入&quo;任务队列&quo;（ask quu）的任务，只有&quo;任务队列&quo;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。”，这句让人理解的意思是“任务队列”主动通知“主线程”。而后面所表达的却是“主线程”在执行栈清空后才会到任务队列中取任务。前后主被动关系矛盾啊。  还有，“（2）主线程之外，还存在一个&quo;任务队列&quo;（ask quu）。只要异步任务有了运行结果，就在&quo;任务队列&quo;之中放置一个事件。”。这时异步任务还在队列里没执行呢，怎么就会有了运行结果呢？  烦请阮老师在方便的时候不吝赐教。同时，感谢阮老师每次耐心细致的讲解和分享！  
           
            2015年4月 5日 11:28 | # | 引用  
           
          
         
         
          
           
             ocansick 说：   
           
           定时器执行流程还是没讲清楚。。。。  
           
            2015年4月 7日 19:49 | # | 引用  
           
          
         
         
          
           
             imdus 说：   
           
           能说说这个网站是怎么建 的么  
           
            2015年4月 9日 01:44 | # | 引用  
           
          
         
         
          
           
             云霄 说：   
           
           不管扑灵和你都写的云里雾里的。。。不透彻。。  
           
            2015年7月 6日 20:05 | # | 引用  
           
          
         
         
          
           
             青苔 说：   
           
           老师你好，请教个问题，如果是如图示xcuion Conx Sack所展示的那样，岂不是后来的Conx先执行？  那为何  consol.log(a);  consol.log(b);  可以得到我们所要的执行顺序呢？  
           
            2015年7月12日 16:28 | # | 引用  
           
          
         
         
          
           
             andy 说：   
           
           上面代码中，sImmdia和simou被封装在一个sImmdia里面，它的运行结果总是1IMOU FIRD2，这时函数A一定在imou前面触发。  结果不总是1IMOU FIRD2 还可能是IMOU12。  nod 版本v0.12.2 windows 64位系统     
           
            2015年8月25日 17:43 | # | 引用  
           
          
         
         
          
           
             manxisuo 说：   
           
           @腊月乘凉：  的确，这个地方阮老师的说法是不对的。两者并不等价。  
           
            2015年9月 6日 13:45 | # | 引用  
           
          
         
         
          
           
             manxisuo 说：   
           
           给大家推荐一篇，把vn Loop讲得非常清楚的文章：  hps://dvlopr.mozilla.org/nUS/docs/Wb/JavaScrip/vnLoop  中文：  hps://dvlopr.mozilla.org/zhCN/docs/Wb/JavaScrip/vnLoop  
           
            2015年9月14日 13:56 | # | 引用  
           
          
         
         
          
           
             harol 说：   
           
           问题图片丢失。  
           
            2015年9月23日 10:20 | # | 引用  
           
          
         
         
          
           
             shzl 说：   
           
           执行栈（xcuion conx sack）清空的时机是什么？  
           
            2015年9月26日 12:30 | # | 引用  
           
          
         
         
          
           
             kirio 说：   
           
           
            引用简陋的以数据的发言：  感觉文章的表述有些乱，比如“不进入主线程、而进入&quo;任务队列&quo;（ask quu）的任务，只有&quo;任务队列&quo;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。”，这句让人理解的意思是“任务队列”主动通知“主线程”。而后面所表达的却是“主线程”在执行栈清空后才会到任务队列中取任务。前后主被动关系矛盾啊。  还有，“（2）主线程之外，还存在一个&quo;任务队列&quo;（ask quu）。只要异步任务有了运行结果，就在&quo;任务队列&quo;之中放置一个事件。”。这时异步任务还在队列里没执行呢，怎么就会有了运行结果呢？  烦请阮老师在方便的时候不吝赐教。同时，感谢阮老师每次耐心细致的讲解和分享！  同惑啊，“异步任务有了运行结果，就在任务队列之中放置一个事件”，这句不大理解呢，文中不是说同步任务清空之后才执行任务队列的么？前面这个异步的结果是哪里的？求解~~  
           
            2015年10月 9日 15:17 | # | 引用  
           
          
         
         
          
           
             夏爽 说：   
           
           window.onload = funcion(){  documn.onmousdown = funcion(){  var oInpu = documn.cralmn(&quo;inpu&quo;);  oInpu.valu = &quo;输入内容&quo;;  documn.body.appndChild(oInpu);  oInpu.focus();  oInpu.slc();  }  }  为什么把onmousdowm换成onclick在i与chrom下显示效果不同  
           
            2015年10月17日 21:40 | # | 引用  
           
          
         
         
          
           
             fans 说：   
           
           大神我有个问题，如何判断主线程结束，可以进入队列。什么时候能第二次进入主线程。  
           
            2015年11月 8日 21:44 | # | 引用  
           
          
         
         
          
           
             alx 杰 说：   
           
           技术学术自然有需要严谨的地方，老师自然不可能触类旁引，将各个面都涉及的东西讲透，所以有些语言带过，也有确实考虑不周的地方。同样是做技术的，我觉有人跟进技术潮流，出来讲就很好了，至少人家在治学，敢于发表，听取意见。  
           
            2015年12月 5日 14:40 | # | 引用  
           
          
         
         
          
           
             Lion 说：   
           
           文中提到 “如果将simou()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。”，  提到“sImmdia方法则是在当前&quo;任务队列&quo;的尾部添加事件”，  又提到“Nod.js文档中称，sImmdia指定的回调函数，总是排在simou前面”。  这三块东西逻辑矛盾了，肯定有谁出错了，求指点。  
           
            2015年12月23日 16:13 | # | 引用  
           
          
         
         
          
           
             om 说：   
           
           所有windows平台的软件都基于消息队列循环方式。浏览器只是普通的windows本地程序，和winform,mfc等都是同样的机制  
           
            2015年12月31日 14:16 | # | 引用  
           
          
         
         
          
           
             jus coding 说：   
           
           读了3遍，还是有一些不太理解的地方。  比如：同步任务执行完毕之后，才会去执行异步任务。  那会不会出现这样一种情况，a,b,c,d,是同步任务。1,2,3是异步任务。  当a,b,c,d, 执行完毕之后，主线程立马就去将异步任务1,2,3全部读入执行栈，还是按顺序只读取第一个？  那如果，a,b,c,d,执行完毕之后，会不会在某种情况下，c又要重新执行一次？那此时的c算同步任务还是异步任务？  还有，到底何种任务叫同步任务，何种任务又要异步任务？  我初浅的理解是：一般浏览器的默认执行行为，比如 dom加载，css渲染之类的都叫同步任务。  click,onload之类的都叫异步任务。  理由是：前者在浏览器整个生命周期中，都算一种比较固定的步骤，每一次都要执行。且绝大多数任务都需要等待这些任务执行完毕之后才能执行。也就是说，前者是后者的载体。  异步任务：说实话，我不太理解。比较耗时的任务？不属于那种生命周期必须执行的任务（比如click）？  所以，当一个浏览器打开源代码给我看，我不太能指出哪些是同步任务，哪一些又是异步任务。  但我得到的收获是：javascrip是单线程的，开浏览器的时候，会有一些默认每次都要执行的代码属于主任务，它们放在执行堆栈上，当它们执行完毕之后，主线程会去异步队列去找那一些准备好了的任务接着执行。前者执行完毕，循环的主要是后者那些异步队列里的任务了。   
           
            2016年1月 3日 20:26 | # | 引用  
           
          
         
         
          
           
             k 说：   
           
           看得我肚子饿了  
           
            2016年3月11日 17:44 | # | 引用  
           
          
         
         
          
           
             a 说：   
           
           这文章误导人啊  
           
            2016年4月13日 22:03 | # | 引用  
           
          
         
         
          
           
             LSir 说：   
           
           
            引用简陋的以数据的发言：  感觉文章的表述有些乱，比如“不进入主线程、而进入&quo;任务队列&quo;（ask quu）的任务，只有&quo;任务队列&quo;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。”，这句让人理解的意思是“任务队列”主动通知“主线程”。而后面所表达的却是“主线程”在执行栈清空后才会到任务队列中取任务。前后主被动关系矛盾啊。  还有，“（2）主线程之外，还存在一个&quo;任务队列&quo;（ask quu）。只要异步任务有了运行结果，就在&quo;任务队列&quo;之中放置一个事件。”。这时异步任务还在队列里没执行呢，怎么就会有了运行结果呢？  烦请阮老师在方便的时候不吝赐教。同时，感谢阮老师每次耐心细致的讲解和分享！  第一个问题阮老师表述可能有问题，但是意思还是执行完js主线程的代码才会去看浏览器任务队列中的事件，再执行js代码中该事件对应的代码。  第二个问题我的理解是，任务队列里放的是ajax这类的任务，是交给浏览器发起HP请求去执行的，当有了返回结果就会在任务队列中增加一个事件表示该ajax请求已经返回了结果，任务队列里的任务和js主线程是同时执行的。 不影响js是单线程的这个结论，只能说浏览器还会提供接口来供js实现异步操作。  
           
            2016年6月28日 12:26 | # | 引用  
           
          
         
         
          
           
             swvvck 说：   
           
           
            引用青苔的发言：  老师你好，请教个问题，如果是如图示xcuion Conx Sack所展示的那样，岂不是后来的Conx先执行？  那为何  consol.log(a);  consol.log(b);  可以得到我们所要的执行顺序呢？  xcuion Conx Sack 存放的是调用关系，你的例子的顺序是consol.log(a); 入栈直接运行后出栈，然后consol.log(b);入栈，执行后出栈；  如果例子是这样：  funcion log() {  consol.log(argumns);  }  log(a);  那么出入栈顺序是，log(a); 入栈，consol.log(a);入栈，执行consol.log(a);出栈，log(a);出栈；  如果觉得我说的不是很清楚，建议看看这个视频：hp://vimo.com/96425312  
           
            2016年7月25日 21:51 | # | 引用  
           
          
         
         
          
           
             hlloworld 说：   
           
           
            引用LSir的发言：    第一个问题阮老师表述可能有问题，但是意思还是执行完js主线程的代码才会去看浏览器任务队列中的事件，再执行js代码中该事件对应的代码。  第二个问题我的理解是，任务队列里放的是ajax这类的任务，是交给浏览器发起HP请求去执行的，当有了返回结果就会在任务队列中增加一个事件表示该ajax请求已经返回了结果，任务队列里的任务和js主线程是同时执行的。 不影响js是单线程的这个结论，只能说浏览器还会提供接口来供js实现异步操作。  还是你解释的比较清楚。  
           
            2016年9月12日 17:22 | # | 引用  
           
          
         
         
          
           
             windr 说：   
           
           sImmdia(funcion (){  sImmdia(funcion A() {  consol.log(1);  sImmdia(funcion B(){consol.log(2);});  });  simou(funcion imou() {  consol.log(IMOU FIRD);  }, 0);  });  阮老师, 上面的例子, 在测试中也有下面的情况:  IMOU FIRD  1  2  我的nod版本v5.11.0  关于 simou感觉它会在插队&quo;任务队列&quo;(时间点到了,就优先插队到任务队列队首)  
           
            2016年10月18日 10:55 | # | 引用  
           
          
         
         
          
           
             ambr 说：   
           
           发现我们培训老师讲的课应该是借鉴了阮老师的文章。。。有的原话都一样。。  
           
            2016年10月23日 20:06 | # | 引用  
           
          
         
         
          
           
             叮当卡丁 说：   
           
           “挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。”  这句话我有一点不解，这个异步任务是要等所有同步任务都执行完毕了之后进入主线程呢？还是只要有IO设备返回结果就立马进入主线程，可以插队到已在主线程的同步任务前面？  
           
            2016年11月 4日 17:32 | # | 引用  
           
          
         
         
          
           
             Alln 说：   
           
           自定义的回调函数会放到消息队列中吗？  
           
            2016年11月11日 10:28 | # | 引用  
           
          
         
         
          
           
             Jim 说：   
           
           关于sImmdia和simou的执行顺序，确实是不定的：  sImmdia(funcion (){  simou(funcion imou() {  consol.log(同一loop中的simou方法执行，输出：IMOU FIRD);  }, 0);  consol.log(和 simou、sImmdia 同一层次的代码执行);  sImmdia(funcion A() {  ** consol.log(同一loop中的sImmdia 方法执行， 输出：1 );  sImmdia(funcion B(){consol.log(下一loop中的sImmdia 方法执行， 输出：2);});  });  });  执行结果：  和 simou、sImmdia 同一层次的代码执行  同一loop中的simou方法执行，输出：IMOU FIRD  同一loop中的sImmdia 方法执行， 输出：1  下一loop中的sImmdia 方法执行， 输出：2  如果注释掉标记为**的那行代码：  sImmdia(funcion (){  simou(funcion imou() {  consol.log(同一loop中的simou方法执行，输出：IMOU FIRD);  }, 0);  // consol.log(和 simou、sImmdia 同一层次的代码执行);  sImmdia(funcion A() {  consol.log(同一loop中的sImmdia 方法执行， 输出：1 );  sImmdia(funcion B(){consol.log(下一loop中的sImmdia 方法执行， 输出：2);});  });  });  执行结果：  同一loop中的sImmdia 方法执行， 输出：1  同一loop中的simou方法执行，输出：IMOU FIRD  下一loop中的sImmdia 方法执行， 输出：2  
           
            2016年11月24日 15:50 | # | 引用  
           
          
         
         
          
           
             Jim 说：   
           
           上面的**标记错了，应该是上边那句consol：  sImmdia(funcion (){  simou(funcion imou() {  consol.log(同一loop中的simou方法执行，输出：IMOU FIRD);  }, 0);  ** consol.log(和 simou、sImmdia 同一层次的代码执行);  sImmdia(funcion A() {  consol.log(同一loop中的sImmdia 方法执行， 输出：1 );  sImmdia(funcion B(){consol.log(下一loop中的sImmdia 方法执行， 输出：2);});  });  });  
           
            2016年11月24日 15:52 | # | 引用  
           
          
         
         
          
           
             Jim 说：   
           
           文章写得很好，书也写得好！  hp://s6.ruanyifng.com/#docs/async  
           
            2016年11月24日 15:57 | # | 引用  
           
          
         
         
          
           
             王子龙 说：   
           
           sImmdia(funcion (){  sImmdia(funcion A() {  consol.log(1);  sImmdia(funcion B(){consol.log(2);});  });  simou(funcion imou() {  consol.log(3);  }, 0);  });  上面这个代码的输出顺序实际上也是随机的。可能是 1，3，2；也可能是3，1，2.  在 I/O 操作的回调里，他们的顺序才不是随机的:  fs.radFil(../../RADM.md, () =&g; {  simou(() =&g; {  consol.log(1)  }, 0);  sImmdia(() =&g; {  consol.log(2)  });  });  总是先输出2， 再输出1. 文档提到的：  h main advanag o using sImmdia() ovr simou() is sImmdia() will always b xcud bfor any imrs if schduld wihin an I/O cycl, indpndnly of how many imrs ar prsn.  —— hps://gihub.com/nodjs/nod/blob/masr/doc/opics/vnloopimrsandnxick.md  
           
            2016年12月30日 15:02 | # | 引用  
           
          
         
         
          
           
             losymar 说：   
           
           呀 朴灵老师批注找不到了  
           
            2016年12月30日 16:37 | # | 引用  
           
          
         
         
          
           
             kvin 说：   
           
           如果执行栈（主线程）在执行完正要loop任务队列前，主线程的代码又被触发执行了一次会怎么样？比如两次点击，是会先执行任务队列还是主线程的代码  
           
            2017年1月 9日 14:56 | # | 引用  
           
          
         
         
          
           
             和中堂 说：   
           
           阮老师是一位不错的践行者，我前端典范。  
           
            2017年1月18日 14:11 | # | 引用  
           
          
         
         
          
           
             goodyboy6 说：   
           
           
            引用fans的发言：  大神我有个问题，如何判断主线程结束，可以进入队列。什么时候能第二次进入主线程。  `vn quu`中新增加vn(比如点击) 和 `任务队列`中任务完成触发回调都会再次进入主线程。 
           
           
            2017年2月 7日 10:59 | # | 引用  
           
          
         
         
          
           
             goodyboy6 说：   
           
           根据MDN上官方的描述：  &g; h vn loop go is nam bcaus of how is usually implmnd, which usually rsmbls:   whil (quu.waiForMssag()) {  quu.procssNxMssag();  }   quu.waiForMssag wais synchronously for a mssag o arriv if hr is non currnly.  这篇文章中大量的关于主线程`主动获取任务事件结束回调`的描述是错误的。回调会让`quu.waiForMssag()`返回`ru`，激活新的vn loop，从而及时处理回调。  
           
            2017年2月 7日 11:38 | # | 引用  
           
          
         
         
          
           
             hank 说：   
           
           sImmdia(funcion (){  sImmdia(funcion A() {  consol.log(1);  sImmdia(funcion B(){consol.log(2);});  });  simou(funcion imou() {  consol.log(IMOU FIRD);  }, 0);  });  // 1  // IMOU FIRD  // 2  上面代码中，sImmdia和simou被封装在一个sImmdia里面，它的运行结果总是1IMOU FIRD2  阮老师，我测试的这个运行结果。也是不确定的，还有可能是IMOU FIRD12  
           
            2017年2月19日 17:43 | # | 引用  
           
          
         
         
          
           
             yyf 说：   
           
           一直有一个疑问未能解开，vn Loop这个机制是不是由一个单独的（浏览器/nod）线程控制，比如simou(()=&g;{}, 1000)方法，延迟1000ms，是谁来监控这1000ms后加入消息quu的，是浏览器的某个(事件处理)线程么？  
           
            2017年2月27日 12:15 | # | 引用  
           
          
         
         
          
           
             杨守科 说：   
           
           
            引用yyf的发言：  一直有一个疑问未能解开，vn Loop这个机制是不是由一个单独的（浏览器/nod）线程控制，比如simou(()=&g;{}, 1000)方法，延迟1000ms，是谁来监控这1000ms后加入消息quu的，是浏览器的某个(事件处理)线程么？  对的 之前我也很疑惑 如果是单线程只能做一件事 执行到simou 或ajax之后 把他们放入&quo;事件池&quo; 再去执行后续的代码 这个时候就会出现问题 说好的单线程只能做一件事的引擎怎么一边监控事件池的状态一边执行后续的代码呢？ 后来偶然看到一位大牛的博客翻译了一篇墙外的文章才突然顿悟（文章地址找不到了）。因为浏览器是多线程啊 当浏览器监控到&quo;事件池&quo;状态更新时会通知改变js引擎 这时候js引擎会在空闲的时候停下来去执行&quo;事件池&quo;里面的回调 所谓空闲的时候是指的是当前引擎执行的语句块上下文执行完毕时的正要执行下一个语句块时的状态 比如你在 simou(()=&g;{consol.log(1000 nd)}, 1000) 后面写个for的死循环 因为单线程 你永远也无法得到输出 或是在simou后面写一个函数让其循环1300后它就会在1300后去回调输出而不是1000后  
           
            2017年3月19日 16:13 | # | 引用  
           
          
         
        
        我要发表看法  
           
          
           
           
           
           
           
           
           
           
            您的留言 （HML标签部分可用）    
            您的大名：    &laquo;必填  
            电子邮件：    &laquo;必填，不公开  
            个人网址：    &laquo;我信任你，不会填写广告链接  
            记住个人信息？   
        
    
   
   
   分享按钮 
    
    
   
   
  
